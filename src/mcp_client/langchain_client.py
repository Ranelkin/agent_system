import asyncio
import json
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from typing import Any, Dict, Optional
from log_config import setup_logging
logger = setup_logging("session_manager")

class MCPTool:
    def __init__(self, server_command):
        """_______GENERATED BY CODE_AGENT_______
        Initialize MCPTool with server command details and setup for connection.
        """
        self.server_command = server_command
        self.mcp_server = StdioServerParameters(
            command="python3",
            args=["-m", "src.mcp_server.mcp_server"],
            env=None  
        )
        self.session: Optional[ClientSession] = None
        self.read = None
        self.write = None
        self.client_context = None
        self.loop = None
        
    def connect(self):
        """Synchronous connection wrapper"""
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        
        async def _connect():
            """Establish the connection to the MCP server and initialize session."""
            # Create client context (stdio-based client) for server communication
            self.client_context = stdio_client(self.mcp_server)
            # Acquire reader and writer streams from the client context
            self.read, self.write = await self.client_context.__aenter__()
            # Create a client session with the obtained streams
            self.session = ClientSession(self.read, self.write)
            # Enter the session context
            await self.session.__aenter__()
            # Perform initialization routines within the session
            await self.session.initialize()
            
        self.loop.run_until_complete(_connect())
        logger.info("MCP client connection established")
        
    def disconnect(self):
        """Synchronous disconnection wrapper"""
        if not self.loop:
            return
            
        async def _disconnect():
            """Cleanly close the session and client context."""
            # Exit the session context if it exists
            if self.session:
                await self.session.__aexit__(None, None, None)
            # Exit the client context if it exists
            if self.client_context:
                await self.client_context.__aexit__(None, None, None)
                
        self.loop.run_until_complete(_disconnect())
        self.loop.close()
        logger.info("MCP client connection closed")
        
    def call_tool(self, tool_name: str, args: Dict[str, Any]) -> str:
        """Synchronous tool call wrapper"""
        async def _call():
            """Call a tool asynchronously and format the result as a JSON string."""
            # Call the specified tool with arguments within the session
            result = await self.session.call_tool(tool_name, arguments=args)
            # Return the result as pretty-printed JSON if dict, else as string
            return json.dumps(result, indent=2) if isinstance(result, dict) else str(result)
            
        return self.loop.run_until_complete(_call())
    
    