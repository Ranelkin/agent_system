from langchain.tools import Tool
from langgraph.prebuilt import create_react_agent
from typing import Optional
from .mcp_client import MCPTool
from ....model.agent import llm
from ....shared.log_config import setup_logging

logger = setup_logging("session_manager")

class MCPSessionManager:
    def __init__(self):
        """Initialize the session manager with no active MCP tool."""
        self.mcp_tool: Optional[MCPTool] = None
        
    def start(self):
        """Start persistent connection to the MCP server.
        
        _______GENERATED BY CODE_AGENT_______
        """
        logger.info("Starting MCPSessionManager...")
        self.mcp_tool = MCPTool(["python3", "-m", "src.mcp_server.mcp_server"])
        self.mcp_tool.connect()
        return self.mcp_tool
    
    def stop(self):
        """Stop persistent connection to the MCP server.
        
        _______GENERATED BY CODE_AGENT_______
        """
        logger.info("Stopping MCPSessionManager...")
        if self.mcp_tool:
            self.mcp_tool.disconnect()
            
    def get_tools(self):
        """Retrieve tools that interact with the MCP server.
        
        Raises:
            RuntimeError: If the session has not been started.
        
        Returns:
            list: A list of configured Tool objects for web search and code documentation.
        
        _______GENERATED BY CODE_AGENT_______
        """
        if not self.mcp_tool:
            raise RuntimeError("MCP session not started. Call start() first.")
        
        # Define inner functions that wrap the MCPTool calls
        def search_tool(query: str) -> str:
            """Use the MCP tool to perform a web search.
            
            Args:
                query (str): The search query.
            Returns:
                str: The search results.
            """
            return self.mcp_tool.call_tool("search", {"search_term": query})
        
        def unit_test_tool(dir: str) -> str: 
            """Use the MCP tool to generate unit tests for a codebase 

            Args:
                dir (str): The directory path 

            Returns:
                str: The unit test output 
            """
            logger.info(f"Start to create unit tests for dir: {dir}")
            result = self.mcp_tool.call_tool("create_unit_tests", {"dir": dir}) 
            return result 
        
        def comment_codebase_tool(dir: str)->str: 
            logger.info(f"Start to commnt out codebase for dir: {dir}")
            result = self.mcp_tool.call_tool("comment_codebase", {"dir": dir}) 
            return result
        # Return the list of tools with descriptions and functions
        
        return [
            Tool(
                name="web_search",
                func=search_tool,
                description="Search the web for information"
            ),
            Tool(
                name="comment_codebase",
                func=comment_codebase_tool,
                description="Tool to Comment out / document codebase"
            ),
            Tool(
                name="create_unit_test", 
                func=unit_test_tool, 
                description="Generate Unit tests for a codebase. Pass the full directory path as the argument."
            )
        ]


def chat_session():
    """Main chat session - fully synchronous
    
    _______GENERATED BY CODE_AGENT_______
    """
    
    manager = MCPSessionManager()
    manager.start()
    
    try:
        tools = manager.get_tools()
        
        system_prompt = """You are an AI assistant that can search the web or document codebases.

        When asked to document a codebase:
        1. Extract the EXACT directory path from the user's message
        2. Call the document_codebase tool with that exact path as the argument
        3. Return the tool's output
        4. Do NOT make multiple calls or suggest alternative paths

        For other queries, use the Web Search tool if applicable."""
        
        # Create the agent WITHOUT a prompt template
        # create_react_agent handles the messaging internally
        agent = create_react_agent(
            llm, 
            tools,
            prompt=system_prompt  # Pass system prompt as state_modifier
        )
        
        # Chat loop
        logger.info("\nðŸ¤– AI Assistant ready! (type 'exit' to quit)\n")
        while True:
            query = input("You: ")
            if query.lower() in ['exit', 'quit', 'q']:
                break
            
            logger.info("\nAssistant: ")
            try:
                response = agent.invoke(
                    {"messages": [("system", system_prompt), ("human", query)]},
                    config={"recursion_limit": 50}
                )
                
                # Extract and log the response message content
                if "messages" in response and response["messages"]:
                    final_message = response["messages"][-1]
                    if hasattr(final_message, 'content'):
                        logger.info(final_message.content)
                    else:
                        logger.info(final_message)
                else:
                    logger.info(response)
                    
            except Exception as e:
                logger.error(f"Error in chat: {e}")
                logger.info(f"Error: {e}")
            
            logger.info("\n\n")  
                
    finally:
        logger.info("Finished processing request")
        manager.stop()
        logger.info("\nðŸ‘‹ Goodbye!")
        



